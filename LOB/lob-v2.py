# -*- coding: utf-8 -*-
"""Notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nN7FtU8Q5uAiatXHr_VcZxpOw5OOIpHS
"""

import heapq
import time

start_time = time.perf_counter()

class Order:
  def __init__(self, order_id, is_buy, quantity, price):
    self.id = order_id
    self.is_buy = is_buy
    self.quantity = quantity
    self.price = price

class PriceLevel:
  def __init__(self, price):
    self.price = price
    self.orders = []
    self.total_quantity = 0

  def add_order(self, order):
    # Include order.id for tie-breaking in heapq comparison
    heapq.heappush(self.orders, (order.price, order.id, order))
    self.total_quantity += order.quantity

  def remove_order(self,order_id):
    # Need to rebuild the heap after removing an item
    for idx, (price, order_id_in_tuple, order) in enumerate(self.orders):
      if order_id_in_tuple == order_id:
        self.total_quantity -= order.quantity
        del self.orders[idx]
        heapq.heapify(self.orders) # Rebuild heap after deletion
        break

class OrderBook:
  def __init__(self):
    self.bids = [] # Max heap for bids (negative prices)
    self.asks = [] # Min heap for asks
    self.bid_price_map = {}
    self.ask_price_map = {}
    self.order_id_map = {}
    self.order_id_counter = 0

  def add_order(self, is_buy, quantity, price):
    self.order_id_counter += 1
    order = Order(self.order_id_counter,is_buy,quantity, price)
    self.order_id_map[order.id] = order
    if is_buy:
      if price in self.bid_price_map:
        price_level = self.bid_price_map[price]
      else:
        price_level = PriceLevel(price)
        # Use negative price for max heap and store price level object
        heapq.heappush(self.bids, (-price_level.price, price_level))
        self.bid_price_map[price] = price_level
      price_level.add_order(order)
    else:
      if price in self.ask_price_map:
          price_level = self.ask_price_map[price]
      else:
          price_level = PriceLevel(price)
          # Store price level object in min heap
          heapq.heappush(self.asks, (price_level.price, price_level))
          self.ask_price_map[price] = price_level
      price_level.add_order(order)


  def cancel_order(self, order_id):
    if order_id in self.order_id_map:
      order = self.order_id_map[order_id]
      if order.is_buy:
        price_level = self.bid_price_map[order.price]
        price_level.remove_order(order_id)
        if price_level.total_quantity == 0:
          # Remove the price level from the heap if it's empty
          # This requires rebuilding the heap which can be inefficient
          # A more efficient approach would be lazy removal
          if (-price_level.price, price_level) in self.bids: # Check if the price level is still in the heap
              self.bids.remove((-price_level.price, price_level))
              heapq.heapify(self.bids)
          del self.bid_price_map[order.price]
      else:
        price_level = self.ask_price_map[order.price]
        price_level.remove_order(order_id)
        if price_level.total_quantity == 0:
          # Remove the price level from the heap if it's empty
          if (price_level.price, price_level) in self.asks: # Check if the price level is still in the heap
              self.asks.remove((price_level.price, price_level))
              heapq.heapify(self.asks)
          del self.ask_price_map[order.price]
      del self.order_id_map[order_id]

  def execute_traders(self):
    while self.bids and self.asks:
        # Get the best bid and ask price levels
        best_bid_price, bid_level = self.bids[0]
        best_ask_price, ask_level = self.asks[0]

        # Adjust for negative price in bid heap
        best_bid_price = -best_bid_price

        if best_bid_price < best_ask_price:
            break # No match

        if not bid_level.orders or not ask_level.orders:
            # This should not happen if price levels are removed when empty, but adding a check
            if not bid_level.orders and (-best_bid_price, bid_level) in self.bids:
                 self.bids.remove((-best_bid_price, bid_level))
                 heapq.heapify(self.bids)
            if not ask_level.orders and (best_ask_price, ask_level) in self.asks:
                 self.asks.remove((best_ask_price, ask_level))
                 heapq.heapify(self.asks)
            continue


        # Access the actual Order objects from the tuples in PriceLevel orders
        bid_order = bid_level.orders[0][2]
        ask_order = ask_level.orders[0][2]


        trade_qty = min(bid_order.quantity, ask_order.quantity)

        print(f"Trade executed: {trade_qty} at price {best_ask_price}")

        # Update quantities
        bid_order.quantity -= trade_qty
        ask_order.quantity -= trade_qty

        # Remove orders if fully filled
        if bid_order.quantity == 0:
            bid_level.remove_order(bid_order.id)
            if bid_level.total_quantity == 0:
                # Remove the price level from the heap and map if it's empty
                heapq.heappop(self.bids) # Remove the best bid price level from the heap
                del self.bid_price_map[best_bid_price]

        if ask_order.quantity == 0:
            ask_level.remove_order(ask_order.id)
            if ask_level.total_quantity == 0:
                # Remove the price level from the heap and map if it's empty
                heapq.heappop(self.asks) # Remove the best ask price level from the heap
                del self.ask_price_map[best_ask_price]


  def print_order_book(self):
    print("Bids:")
    # Sort by price descending for bids
    for price in sorted(self.bid_price_map.keys(), reverse = True):
        level = self.bid_price_map[price]
        print(f"Price: {price}, Quantity: {level.total_quantity}, Orders: {level.orders}")
    print("\nAsks:")
    # Sort by price ascending for asks
    for price in sorted(self.ask_price_map.keys()):
      level = self.ask_price_map[price]
      print(f"Price: {price}, Quantity: {level.total_quantity}, Orders: {level.orders}")


if __name__ == "__main__":
  ob = OrderBook()
  ob.add_order(True, 100, 10.0)
  ob.add_order(False, 200, 10.0)
  ob.add_order(True, 150, 11.0)

  ob.add_order(False, 150, 11)
  ob.add_order(False, 100, 10)

  ob.print_order_book()

  ob.execute_traders()

  ob.print_order_book()

  ob.cancel_order(2)

  ob.print_order_book()

end_time = time.perf_counter()
execution_time = end_time - start_time
print(f"Execution time: {execution_time:.6f} seconds")